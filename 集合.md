# 一、体系概述

​       **集合类**

- 为什么出现集合类？

​       面向对象语言对事物的体现都是以对象的形式，所以为了方便对多个对象的操作，
       就对对象进行存储，集合就是存储对象常用的一 种方式。

- 数组和集合类同是容器，有何不同？ 

​        数组虽然也可以存储对象，但长度是固定的；集合长度是可变的。
        数组中可以存储基本数据类型，集合只能存储对象。

- 集合类的特点

​        集合只用于存储对象，集合长度是可变的，集合可以存储不同类型的对象。

# 二、Collection接口

 **共性方法**

Collection定义了集合框架的共性功能。
1，添加
	add(e);
	addAll(collection);

2，删除
	remove(e);
	removeAll(collection);
	clear();

3，判断。
	contains(e);
	isEmpty();

4，获取
	iterator();
	size();

5，获取交集。
	retainAll();

6，集合变数组。
	toArray();

注意：

- add方法的参数类型是Object，以便于接收任意类型对象。
- 集合中存储的都是对象的引用(地址)

什么是迭代器呢？
其实就是集合的取出元素的方式，如同抓娃娃游戏机中的夹子。
迭代器是取出方式，会直接访问集合中的元素，
所以将迭代器通过内部类的形式来进行描述。
通过容器的iterator()方法获取该内部类的对象。

~~~java
class  CollectionDemo
{
	public static void main(String[] args) 
	{		
		method_get();
	}
    
	public static void method_get()
	{
		ArrayList al = new ArrayList();

		//1，添加元素。
		al.add("java01");//add(Object obj);
		al.add("java02");
		al.add("java03");
		al.add("java04");

		/*
		Iterator it = al.iterator();//获取迭代器，用于取出集合中的元素。

		while(it.hasNext())
		{
			sop(it.next());
		}
		*/

		for(Iterator it = al.iterator(); it.hasNext() ; )
		{
			sop(it.next());
		}
	}


	public static void method_2()
	{
		ArrayList al1 = new ArrayList();

		al1.add("java01");
		al1.add("java02");
		al1.add("java03");
		al1.add("java04");
		ArrayList al2 = new ArrayList();

		al2.add("java03");
		al2.add("java04");
		al2.add("java05");
		al2.add("java06");
		
		//al1.retainAll(al2);//取交集，al1中只会保留和al2中相同的元素。
		al1.removeAll(al2);

		sop("al1:"+al1);
		sop("al2:"+al2);
	}

	public static void base_method()
	{
		//创建一个集合容器。使用Collection接口的子类。ArrayList
		ArrayList al = new ArrayList();

		//1，添加元素。
		al.add("java01");//add(Object obj);
		al.add("java02");
		al.add("java03");
		al.add("java04");

		//打印原集合。
		sop("原集合:"+al);

		//3，删除元素。
		//al.remove("java02");
		//al.clear();//清空集合。

		//4，判断元素。
		sop("java03是否存在:"+al.contains("java03"));
		sop("集合是否为空？"+al.isEmpty());

		//2，获取个数。集合长度。
		sop("size:"+al.size());

		//打印改变后的集合。
		sop(al);

	}

	public static void sop(Object obj)
	{
		System.out.println(obj);
	}
}
~~~

# 三、List集合

## 共性方法

List：
       特有方法：凡是可以操作角标的方法都是该体系特有的方法。

  增
	add(index,element);
	addAll(index,Collection);

 删
	remove(index);

  改
	set(index,element);

 查
	get(index):
	subList(from,to);
	listIterator();
	int indexOf(obj):获取指定元素的位置。
	ListIterator listIterator();

List集合特有的迭代器：ListIterator是Iterator的子接口。

在迭代时，不可以通过集合对象的方法操作集合中的元素。
因为会发生ConcurrentModificationException（并发修改 ）异常。
所以，在迭代时，只能用迭代器的方法操作元素，可是Iterator方法是有限的，只能对元素进行判断，取出，删除的操作。
如果想要其他的操作如添加，修改等，就需要使用其子接口：ListIterator。
该接口只能通过List集合的listIterator方法获取。

~~~Java
import java.util.*;
class ListDemo 
{
	public static void sop(Object obj)
	{
		System.out.println(obj);
	}
    
	public static void method()
	{
		
		ArrayList al = new ArrayList();

		//添加元素
		al.add("java01");
		al.add("java02");
		al.add("java03");
		
		sop("原集合是："+al);
		//在指定位置添加元素。
		al.add(1,"java09");

		//删除指定位置的元素。
		//al.remove(2);

		//修改元素。
		//al.set(2,"java007");

		//通过角标获取元素。
		sop("get(1):"+al.get(1));

		sop(al);

		//获取所有元素。
		for(int x=0; x<al.size(); x++)
		{
			System.out.println("al("+x+")="+al.get(x));
		}

		Iterator it = al.iterator();

		while(it.hasNext())
		{
			sop("next:"+it.next());
		}
		//通过indexOf获取对象的位置。
		sop("index="+al.indexOf("java02"));

		List sub = al.subList(1,3);

		sop("sub="+sub);
	}
	
	public static void main(String[] args) 
	{

		//演示列表迭代器。
		ArrayList al = new ArrayList();

		//添加元素
		al.add("java01");
		al.add("java02");
		al.add("java03");

		sop(al);

		ListIterator li = al.listIterator();
	
		//sop("hasPrevious():"+li.hasPrevious());

		while(li.hasNext())
		{
			Object obj = li.next();

			if(obj.equals("java02"))
				//li.add("java009");
				li.set("java006");
		}  

		while(li.hasPrevious())
		{
			sop("pre::"+li.previous());
		}
		//sop("hasNext():"+li.hasNext());
		//sop("hasPrevious():"+li.hasPrevious());

		sop(al);
		/*
		//在迭代过程中，准备添加或者删除元素。

		Iterator it = al.iterator();

		while(it.hasNext())
		{
			Object obj = it.next();

			if(obj.equals("java02"))
				//al.add("java008");
				it.remove();//将java02的引用从集合中删除了。

			sop("obj="+obj);
		}
		sop(al);
		*/		
	}
}
~~~

## 具体对象的特点

Collection：
	List: 元素是有序的，元素可以重复。因为该集合体系有索引。
		ArrayList:底层的数据结构使用的是数组结构。特点：查询速度很快，但是增删稍慢，线程不同步。
		LinkedList:底层使用的链表数据结构。特点：增删速度很快，查询稍慢，线程不同步。
		Vector:底层是数组数据结构。线程同步，被ArrayList替代了，因为效率低。
        Set：元素是无序，元素不可以重复。

## Vector中的枚举

枚举就是Vector特有的取出方式。
枚举和迭代器很像，其实枚举和迭代是一样的。
因为枚举的名称以及方法的名称都过长，所以被迭代器取代了。

~~~Java
class VectorDemo 
{
	public static void main(String[] args) 
	{
		Vector v = new Vector();

		v.add("java01");
		v.add("java02");
		v.add("java03");
		v.add("java04");

		Enumeration en = v.elements();

		while(en.hasMoreElements())
		{
			System.out.println(en.nextElement());
		}
	}
}
~~~

## LinkedList

LinkedList特有方法：
addFirst();
addLast();

getFirst();
getLast();
获取元素，但不删除元素。如果集合中没有元素，会出现NoSuchElementException

removeFirst();
removeLast();
获取元素，但是元素被删除。如果集合中没有元素，会出现NoSuchElementException


在JDK1.6出现了替代方法。

offerFirst();
offerLast();

peekFirst();
peekLast();
获取元素，但不删除元素。如果集合中没有元素，会返回null。

pollFirst();
pollLast();
获取元素，但是元素被删除。如果集合中没有元素，会返回null。

~~~java
class LinkedListDemo 
{
	public static void main(String[] args) 
	{
		LinkedList link = new LinkedList();

		link.addLast("java01");
		link.addLast("java02");
		link.addLast("java03");
		link.addLast("java04");

		//sop(link);
//		sop(link.getFirst());
//		sop(link.getFirst());
		//sop(link.getLast());
		//sop(link.removeFirst());
		//sop(link.removeFirst());

		//sop("size="+link.size());

		while(!link.isEmpty())
		{
			sop(link.removeLast());
		}
	}

	public static void sop(Object obj)
	{
		System.out.println(obj);
	}
}
~~~

 使用LinkedList模拟一个堆栈或者队列数据结构。

堆栈：先进后出 ，如同一个杯子。
队列：先进先出 First in First out  FIFO ，如同一个水管。

~~~Java
import java.util.*;
class DuiLie
{
	private LinkedList link;

	DuiLie()
	{
		link = new LinkedList(); 
	}
	
	public void myAdd(Object obj)
	{
		link.addLast(obj);
	}
    
	public Object myGet()
	{
		return link.removeFirst();
	}
    
	public boolean isNull()
	{
		return link.isEmpty();
	}
}

class  LinkedListTest
{
	public static void main(String[] args) 
	{
		DuiLie dl = new DuiLie();
		dl.myAdd("java01");
		dl.myAdd("java02");
		dl.myAdd("java03");
		dl.myAdd("java04");

		while(!dl.isNull())
		{
			System.out.println(dl.myGet());
		}
	}
}
~~~

## Arraylist

- 去除ArrayList集合中的重复元素。

~~~java
class ArrayListTest 
{
	public static void sop(Object obj)
	{
		System.out.println(obj);
	}
	public static void main(String[] args) 
	{
		ArrayList al = new ArrayList();

		al.add("java01");
		al.add("java02");
		al.add("java01");
		al.add("java02");
		al.add("java01");
//		al.add("java03");

		/*
		在迭代时循环中next调用一次，就要hasNext判断一次。
		Iterator it = al.iterator();

		while(it.hasNext())
		{
			sop(it.next()+"...."+it.next());
		}
		*/

		/**/
		sop(al);
		
		al = singleElement(al);

		sop(al);
	}

	public static ArrayList singleElement(ArrayList al)
	{
		//定义一个临时容器。
		ArrayList newAl = new ArrayList();

		Iterator it = al.iterator();

		while(it.hasNext())
		{
			Object obj = it.next();

			if(!newAl.contains(obj))
				newAl.add(obj);
		}
		return newAl;
	}
}
~~~

将自定义对象作为元素存到ArrayList集合中，并去除重复元素。
比如：存人对象。同姓名同年龄，视为同一个人，为重复元素。
思路：
1，对人描述，将数据封装进人对象。
2，定义容器，将人存入。
3，取出。

List集合判断元素是否相同，依据是元素的equals方法。

~~~java
class Person
{
	private String name;
	private int age;
	Person(String name,int age)
	{
		this.name = name;
		this.age = age;
	}
	
	public boolean equals(Object obj)
	{
		if(!(obj instanceof Person))
			return false;

		Person p = (Person)obj;
		//System.out.println(this.name+"....."+p.name);

		return this.name.equals(p.name) && this.age == p.age;
	}
	
	public String getName()
	{
		return name;
	}
	public int getAge()
	{
		return age;
	}
}

class ArrayListTest2 
{
	public static void sop(Object obj)
	{
		System.out.println(obj);
	}
	public static void main(String[] args) 
	{
		ArrayList al = new ArrayList();

		al.add(new Person("lisi01",30));
         //al.add(Object obj);//Object obj = new Person("lisi01",30);
		//al.add(new Person("lisi02",32));
		al.add(new Person("lisi02",32));
		al.add(new Person("lisi04",35));
		al.add(new Person("lisi03",33));
		//al.add(new Person("lisi04",35));
		
		//al = singleElement(al);

		sop("remove 03 :"+al.remove(new Person("lisi03",33)));
         //remove方法底层也是依赖于元素的equals方法。
  
		Iterator it = al.iterator(); 

		while(it.hasNext())
		{
			Person p = (Person)it.next();
			sop(p.getName()+"::"+p.getAge());
		}
	}

	public static ArrayList singleElement(ArrayList al)
	{
		//定义一个临时容器。
		ArrayList newAl = new ArrayList();

		Iterator it = al.iterator();

		while(it.hasNext())
		{
			Object obj = it.next();

			if(!newAl.contains(obj))
				newAl.add(obj);
		}
		return newAl;
	}
}
~~~

# 四、Set集合

## HashSet

Set：元素是无序(存入和取出的顺序不一定一致)，元素不可以重复。
	HashSet:底层数据结构是哈希表，是线程不安全的。不同步。

 TreeSet

HashSet是如何保证元素唯一性的呢？

通过元素的两个方法，hashCode和equals来完成。
如果元素的HashCode值相同，才会判断equals是否为true。
如果元素的hashcode值不同，不会调用equals。

注意：对于判断元素是否存在以及删除等操作，依赖的方法是元素的hashcode和equals方法。

Set集合的功能和Collection是一致的。

~~~java
class HashSetDemo 
{
	public static void sop(Object obj)
	{
		System.out.println(obj);
	}
	public static void main(String[] args) 
	{		
		HashSet hs = new HashSet();

		sop(hs.add("java01"));
		sop(hs.add("java01"));
		hs.add("java02");
		hs.add("java03");
		hs.add("java03");
		hs.add("java04");

		Iterator it = hs.iterator();

		while(it.hasNext())
		{
			sop(it.next());
		}
	}
}
~~~

-  往hashSet集合中存入自定对象，姓名和年龄相同为同一个人，重复元素。

~~~Java
class HashSetTest 
{
	public static void sop(Object obj)
	{
		System.out.println(obj);
	}
	public static void main(String[] args) 
	{
		HashSet hs = new HashSet();

		hs.add(new Person("a1",11));
		hs.add(new Person("a2",12));
		hs.add(new Person("a3",13));
//		hs.add(new Person("a2",12));
//		hs.add(new Person("a4",14));

		//sop("a1:"+hs.contains(new Person("a2",12)));
			
//		hs.remove(new Person("a4",13));
		
		Iterator it = hs.iterator();

		while(it.hasNext())
		{
			Person p = (Person)it.next();
			sop(p.getName()+"::"+p.getAge());
		}
	}
}

class Person
{
	private String name;
	private int age;
	Person(String name,int age)
	{
		this.name = name;
		this.age = age;
	}
	
	public int hashCode()
	{
		System.out.println(this.name+"....hashCode");
		return name.hashCode()+age*37;
	}

	public boolean equals(Object obj)
	{
		if(!(obj instanceof Person))
			return false;

		Person p = (Person)obj;
		System.out.println(this.name+"...equals.."+p.name);

		return this.name.equals(p.name) && this.age == p.age;
	}
	
	public String getName()
	{
		return name;
	}
    
	public int getAge()
	{
		return age;
	}
}
~~~

## TreeSet

Set: 无序，不可以重复元素。
	|--HashSet：数据结构是哈希表。线程是非同步的。
	 保证元素唯一性的原理：判断元素的hashCode值是否相同。
		                      如果相同，还会继续判断元素的equals方法，是否为true。

​        |--TreeSet：可以对Set集合中的元素进行排序。底层数据结构是二叉树。
		保证元素唯一性的依据：compareTo方法return 0.

​       TreeSet排序的第一种方式：让元素自身具备比较性。元素需要实现Comparable接口，覆盖compareTo方法。
				         这种方式也称为元素的自然顺序，或者叫做默认顺序。

​      TreeSet的第二种排序方式：当元素自身不具备比较性时，或者具备的比较性不是所需要的，
				          这时就需要让集合自身具备比较性。在集合初始化时，就有了比较方式。



- 往TreeSet集合中存储自定义对象学生，想按照学生的年龄进行排序。

- 记住，排序时，当主要条件相同时，一定判断一下次要条件。

~~~java
class TreeSetDemo 
{
	public static void main(String[] args) 
	{
		TreeSet ts = new TreeSet();

		ts.add(new Student("lisi02",22));
		ts.add(new Student("lisi007",20));
		ts.add(new Student("lisi09",19));
		ts.add(new Student("lisi08",19));
		//ts.add(new Student("lisi007",20));
		//ts.add(new Student("lisi01",40));

		Iterator it = ts.iterator();
		while(it.hasNext())
		{
			Student stu = (Student)it.next();
			System.out.println(stu.getName()+"..."+stu.getAge());
		}
	}
}


class Student implements Comparable//该接口强制让学生具备比较性。
{
	private String name;
	private int age;

	Student(String name,int age)
	{
		this.name = name;
		this.age = age;
	}

	public int compareTo(Object obj)
	{
		//return 0;
		
		if(!(obj instanceof Student))
			throw new RuntimeException("不是学生对象");
		Student s = (Student)obj;

		System.out.println(this.name+"....compareto....."+s.name);
		if(this.age>s.age)
			return 1;
		if(this.age==s.age)
		{
			return this.name.compareTo(s.name);
		}
		return -1;
	}

	public String getName()
	{
		return name;
	}
    
	public int getAge()
	{
		return age;
	}
}
~~~

### Comparator方式排序

当元素自身不具备比较性，或者具备的比较性不是所需要的。这时需要让容器自身具备比较性。
定义了比较器，将比较器对象作为参数传递给TreeSet集合的构造函数。

当两种排序都存在时，以比较器为主。

定义一个类，实现Comparator接口，覆盖compare方法。

~~~Java
class Student implements Comparable//该接口强制让学生具备比较性。
{
	private String name;
	private int age;

	Student(String name,int age)
	{
		this.name = name;
		this.age = age;
	}

	public int compareTo(Object obj)
	{
		//return 0;
		
		if(!(obj instanceof Student))
			throw new RuntimeException("不是学生对象");
		Student s = (Student)obj;

		//System.out.println(this.name+"....compareto....."+s.name);
		if(this.age>s.age)
			return 1;
		if(this.age==s.age)
		{
			return this.name.compareTo(s.name);
		}
		return -1;
		/**/
	}

	public String getName()
	{
		return name;

	}
	public int getAge()
	{
		return age;
	}
}
class TreeSetDemo2 
{
	public static void main(String[] args) 
	{
		TreeSet ts = new TreeSet(new MyCompare());

		ts.add(new Student("lisi02",22));
		ts.add(new Student("lisi02",21));
		ts.add(new Student("lisi007",20));
		ts.add(new Student("lisi09",19));
		ts.add(new Student("lisi06",18));
		ts.add(new Student("lisi06",18));
		ts.add(new Student("lisi007",29));
		//ts.add(new Student("lisi007",20));
		//ts.add(new Student("lisi01",40));

		Iterator it = ts.iterator();
		while(it.hasNext()) 
		{
			Student stu = (Student)it.next();
			System.out.println(stu.getName()+"..."+stu.getAge());
		}
	}
}

class MyCompare implements Comparator
{
	public int compare(Object o1,Object o2)
	{
		Student s1 = (Student)o1;
		Student s2 = (Student)o2;

		int num = s1.getName().compareTo(s2.getName());
		if(num==0)
		{
			return new Integer(s1.getAge()).compareTo(new Integer(s2.getAge()));
			/*
			if(s1.getAge()>s2.getAge())
				return 1;
			if(s1.getAge()==s2.getAge())
				return 0;
			return -1;
			*/
		}		
		return num;
	}
}
~~~

### 应用

- 按照字符串长度排序。

​       字符串本身具备比较性，但是它的比较方式不是所需要的。这时就只能使用比较器。

~~~Java
import java.util.*;
class  TreeSetTest
{
	public static void main(String[] args) 
	{
		TreeSet ts = new TreeSet(new StrLenComparator());

		ts.add("abcd");
		ts.add("cc");
		ts.add("cba");
		ts.add("aaa");
		ts.add("z");
		ts.add("hahaha");

		Iterator it = ts.iterator();

		while(it.hasNext())
		{
			System.out.println(it.next());
		}
	}
}

class StrLenComparator implements Comparator
{
	public int compare(Object o1,Object o2)
	{
		String s1 = (String)o1;
		String s2 = (String)o2;

		/*
		if(s1.length()>s2.length())
			return 1;
		if(s1.length()==s2.length())
			return 0;
		*/			

		int num = new Integer(s1.length()).compareTo(new Integer(s2.length()));
		if(num==0)
			return s1.compareTo(s2);

		return num;
	}
}
~~~

将字符串中的数值进行排序，使用TreeSet完成。
"90 -7 0 18 2 45 4"

思路
（1）将字符串切割。
（2）可以将这些对象存入TreeSet集合，因为TreeSet自身具备排序功能。

~~~Java
import java.util.*;
class TreeSetTest2 
{
	public static void main(String[] args) 
	{
		ArrayList al = new ArrayList();

		String str = "90 -7 0 18 2 45 4";

		String[] arr = str.split(" ");

		TreeSet ts = new TreeSet();

		for(int x=0; x<arr.length; x++)
		{
			//ts.add(new Integer(arr[x]));
			ts.add(Integer.parseInt(arr[x]));//
		}
		System.out.println(ts);
	}
}
~~~

# 五、泛型

## 泛型概述

泛型：JDK1.5版本以后出现新特性。用于解决安全问题，是一个类型安全机制。

好处：
1. 将运行时期出现问题ClassCastException，转移到了编译时期。
  方便于程序员解决问题，让运行时问题减少，安全。
2. 避免了强制转换麻烦。

泛型格式：通过<>来定义要操作的引用数据类型。

在使用java提供的对象时，什么时候写泛型呢？
通常在集合框架中很常见，只要见到<>就要定义泛型。
其实<> 就是用来接收类型的。
当使用集合时，将集合中要存储的数据类型作为参数传递到<>中即可。

~~~Java
class GenericDemo 
{
	public static void main(String[] args) 
	{
		ArrayList<String> al = new ArrayList<String>();

		al.add("abc01");
		al.add("abc0991");
		al.add("abc014");

		//al.add(4);//al.add(new Integer(4));
		
		Iterator<String> it = al.iterator();
		while(it.hasNext())
		{
			String s = it.next();

			System.out.println(s+":"+s.length());
		}
	}
}
~~~

## 泛型使用

~~~Java
import java.util.*;
class GenericDemo2 
{
	public static void main(String[] args) 
	{
		TreeSet<String> ts = new TreeSet<String>(new LenComparator());

		ts.add("abcd");
		ts.add("cc");
		ts.add("cba");
		ts.add("aaa");
		ts.add("z");
		ts.add("hahaha");


		Iterator<String> it = ts.iterator();

		while(it.hasNext())
		{
			String s = it.next();
			System.out.println(s);
		}
	}
}

class LenComparator implements Comparator<String>
{
	public int compare(String o1,String o2)
	{
		int num = new Integer(o2.length()).compareTo(new Integer(o1.length()));

		if(num==0)
			return o2.compareTo(o1);
		return num;
	}
}
~~~

##  泛型类

什么时候定义泛型类？
当类中要操作的引用数据类型不确定的时候，早期定义Object来完成扩展。
现在定义泛型来完成扩展。

~~~Java
/*
class Tool
{
	private Worker w;
	public void setWorker(Worker w)
	{
		this.w = w;
	}
	public Worker getWorker()
	{
		return w;
	}
}
*/

class Worker
{

}

class Student
{
}

//泛型前做法。
class Tool 
{
	private Object obj;
	public void setObject(Object obj)
	{
		this.obj = obj;
	}
	public Object getObject()
	{
		return obj;
	}
}

class Utils<QQ>
{
	private QQ q;
	public void setObject(QQ q)
	{
		this.q = q;
	}
	public QQ getObject()
	{
		return q;
	}
}


class  GenericDemo3
{
	public static void main(String[] args) 
	{

		Utils<Worker> u = new Utils<Worker>();

		u.setObject(new Student());
		Worker w = u.getObject();;
		/*
		Tool t = new Tool();
		t.setObject(new Student());
		Worker w = (Worker)t.getObject();
		*/
	}
}
~~~

## 泛型方法

泛型类定义的泛型，在整个类中有效。
如果被方法使用，那么泛型类的对象明确要操作的具体类型后，所有要操作的类型就已经固定了。

为了让不同方法可以操作不同类型，而且类型还不确定，那么可以将泛型定义在方法上。

特殊之处：
静态方法不可以访问类上定义的泛型。
如果静态方法操作的应用数据类型不确定，可以将泛型定义在方法上。

~~~Java
/*
class Demo<T>
{
	public void show(T t)
	{
		System.out.println("show:"+t);
	}
	public void print(T t)
	{
		System.out.println("show:"+t);
	}

}
*/

class Demo<T>
{
	public  void show(T t)
	{
		System.out.println("show:"+t);
	}
	public <Q> void print(Q q)
	{
		System.out.println("print:"+q);
	}
	public  static <W> void method(W t)
	{
		System.out.println("method:"+t);
	}
}

class GenericDemo4 
{
	public static void main(String[] args) 
	{
		Demo <String> d = new Demo<String>();
		d.show("haha");
		//d.show(4);
		d.print(5);
		d.print("hehe");

		Demo.method("hahahahha");

		/*
		Demo d = new Demo();
		d.show("haha");
		d.show(new Integer(4));
		d.print("heihei");
		*/
		/*
		Demo<Integer> d = new Demo<Integer>();

		d.show(new Integer(4));
		d.print("hah");

		Demo<String> d1 = new Demo<String>();
		d1.print("haha");
		d1.show(5);
		*/
	}
}
~~~

## 泛型接口

- 泛型定义在接口上。

~~~Java
interface Inter<T>
{
	void show(T t);
}

/*
class InterImpl implements Inter<String>
{
	public void show(String t)
	{
		System.out.println("show :"+t);
	}
}
*/

class InterImpl<T> implements Inter<T>
{
	public void show(T t)
	{
		System.out.println("show :"+t);
	}
}

class GenericDemo5 
{
	public static void main(String[] args) 
	{
		InterImpl<Integer> i = new InterImpl<Integer>();
		i.show(4);
		//InterImpl i = new InterImpl();
		//i.show("haha");
	}
}
~~~

## 泛型限定

? ：通配符，也可以理解为占位符。

泛型的限定：
？ extends E: 可以接收E类型或者E的子类型。上限。
？ super E: 可以接收E类型或者E的父类型。下限。

~~~Java
class  GenericDemo6
{
	public static void main(String[] args) 
	{
		/*
		ArrayList<String> al = new ArrayList<String>();

		al.add("abc1");
		al.add("abc2");
		al.add("abc3");

		ArrayList<Integer> al1 = new ArrayList<Integer>();
		al1.add(4);
		al1.add(7);
		al1.add(1);

		printColl(al);
		printColl(al1);
		*/

		ArrayList<Person> al = new ArrayList<Person>();
		al.add(new Person("abc1"));
		al.add(new Person("abc2"));
		al.add(new Person("abc3"));
		//printColl(al);

		ArrayList<Student> al1 = new ArrayList<Student>();
		al1.add(new Student("abc--1"));
		al1.add(new Student("abc--2"));
		al1.add(new Student("abc--3"));
		printColl(al1);  //ArrayList<? extends Person> al = new ArrayList<Student>();error
	}
    
	public static void printColl(Collection<? extends Person> al)
	{
		Iterator<? extends Person> it = al.iterator();

		while(it.hasNext())
		{
			System.out.println(it.next().getName());
		}
	}
    
	/*
	public static void printColl(ArrayList<?> al)//ArrayList al = new ArrayList<Integer>();error
	{
		Iterator<?> it = al.iterator();

		while(it.hasNext())
		{
			System.out.println(it.next().toString());
		}
	}
	*/
}

class Person
{
	private String name;
	Person(String name)
	{
		this.name = name;
	}
	public String getName()
	{
		return name;
	}
}

class Student extends Person
{
	Student(String name)
	{
		super(name);
	}
}

/*
class Student implements Comparable<Person>//<? super E>
{
	public int compareTo(Person s)
	{
		this.getName()
	}
}
*/

class Comp implements Comparator<Person>
{
	public int compare(Person s1,Person s2)
	{

		//Person s1 = new Student("abc1");
		return s1.getName().compareTo(s2.getName());
	}
}

TreeSet<Student> ts = new TreeSet<Student>(new Comp());
ts.add(new Student("abc1"));
ts.add(new Student("abc2"));
ts.add(new Student("abc3"));
~~~

~~~Java
import java.util.*;
class GenericDemo7 
{
	public static void main(String[] args) 
	{		
		TreeSet<Student> ts = new TreeSet<Student>(new Comp());

		ts.add(new Student("abc03"));
		ts.add(new Student("abc02"));
		ts.add(new Student("abc06"));
		ts.add(new Student("abc01"));
		
		Iterator<Student> it = ts.iterator();

		while(it.hasNext())
		{
			System.out.println(it.next().getName());
		}

		TreeSet<Worker> ts1 = new TreeSet<Worker>(new Comp());

		ts1.add(new Worker("wabc--03"));
		ts1.add(new Worker("wabc--02"));
		ts1.add(new Worker("wabc--06"));
		ts1.add(new Worker("wabc--01"));


		Iterator<Worker> it1 = ts1.iterator();

		while(it1.hasNext())
		{
			System.out.println(it1.next().getName());
		}
	}
}

/*
class StuComp implements Comparator<Student>
{
	public int compare(Student s1,Student s2)
	{
		return s1.getName().compareTo(s2.getName());
	}
}

class WorkerComp implements Comparator<Worker>
{
	public int compare(Worker s1,Worker s2)
	{
		return s1.getName().compareTo(s2.getName());
	}
}
*/

class Comp implements Comparator<Person>
{
	public int compare(Person p1,Person p2)
	{
		return p2.getName().compareTo(p1.getName());
	}
}

class Person
{
	private String name;
	Person(String name)
	{
		this.name = name;
	}
	public String getName()
	{
		return name;
	}
	public String toString()
	{
		return "person :"+name;
	}
}

class Student extends Person
{
	Student(String name)
	{
		super(name);
	}
}

class Worker extends Person
{
	Worker(String name)
	{
		super(name);
	}
}
~~~

# 六、Map集合

## Map概述

Map
	|--Hashtable:底层是哈希表数据结构，不可以存入null键null值。该集合是线程同步的。jdk1.0.效率低。
	|--HashMap：底层是哈希表数据结构，允许使用 null 值和 null 键，该集合是不同步的。将hashtable替代，jdk1.2.效率高。
	|--TreeMap：底层是二叉树数据结构。线程不同步。可以用于给map集合中的键进行排序。

和Set很像，其实Set底层就是使用了Map集合。

## 共性方法

Map集合：该集合存储键值对，一对一对往里存，而且要保证键的唯一性。
	1，添加。
		put(K key, V value) 
		putAll(Map<? extends K,? extends V> m) 

​       2，删除。
		clear() 
		remove(Object key)

​        3，判断。
		containsValue(Object value) 
		containsKey(Object key) 
		isEmpty() 

​        4，获取。
		get(Object key) 
		size() 
		values() 

​                entrySet() 
		keySet() 

~~~Java
import java.util.*;
class  MapDemo
{
	public static void main(String[] args) 
	{
		Map<String,String> map = new HashMap<String,String>();

		//添加元素,添加元素，如果出现添加时，相同的键。那么后添加的值会覆盖原有键对应值。
		//并put方法会返回被覆盖的值。
		System.out.println("put:"+map.put("01","zhangsan1"));
		System.out.println("put:"+map.put("01","wnagwu"));
		map.put("02","zhangsan2");
		map.put("03","zhangsan3");

		System.out.println("containsKey:"+map.containsKey("022"));
		//System.out.println("remove:"+map.remove("02"));

		System.out.println("get:"+map.get("023"));

		map.put("04",null);
		System.out.println("get:"+map.get("04"));
		//可以通过get方法的返回值来判断一个键是否存在。通过返回null来判断。
		
		//获取map集合中所有的值。
		Collection<String> coll = map.values();

		System.out.println(coll);
		System.out.println(map);
	}
}
~~~

## 元素取出方式

map集合的两种取出方式：
1，Set<k> keySet
    将map中所有的键存入到Set集合。因为set具备迭代器，
    所以可以迭代方式取出所有的键，再根据get方法，获取每一个键对应的值。
		
  Map集合的取出原理：将map集合转成set集合，再通过迭代器取出。

2，Set<Map.Entry<k,v>> entrySet
      将map集合中的映射关系存入到了set集合中，而这个关系的数据类型就是：Map.Entry
      Entry其实就是Map中的一个static内部接口。
      为什么要定义在内部呢？
      因为只有有了Map集合，有了键值对，才会有键值的映射关系。
      关系属于Map集合中的一个内部事物，而且该事物在直接访问Map集合中的元素。

~~~java
import java.util.*;

class MapDemo2 
{
	public static void main(String[] args) 
	{
		Map<String,String> map = new HashMap<String,String>();

		map.put("02","zhangsan2");
		map.put("03","zhangsan3");
		map.put("01","zhangsan1");
		map.put("04","zhangsan4");

		//将Map集合中的映射关系取出。存入到Set集合中。
		Set<Map.Entry<String,String>> entrySet = map.entrySet();

		Iterator<Map.Entry<String,String>> it = entrySet.iterator();

		while(it.hasNext())
		{
			Map.Entry<String,String> me = it.next();
			String key = me.getKey();
			String value = me.getValue();

			System.out.println(key+":"+value);

		}

		/*
		//先获取map集合的所有键的Set集合,keySet();
		Set<String> keySet = map.keySet();

		//有了Set集合。就可以获取其迭代器。
		Iterator<String> it = keySet.iterator();

		while(it.hasNext())
		{
			String key = it.next();
			//有了键可以通过map集合的get方法获取其对应的值。
			String value  = map.get(key);
			System.out.println("key:"+key+",value:"+value);
		}

		*/

	}
}

/*
Map.Entry 其实Entry也是一个接口，它是Map接口中的一个内部接口。

interface Map
{
	public static interface Entry
	{
		public abstract Object getKey();
		public abstract Object getValue();
	}
}

class HashMap implements Map
{
	class Hahs implements Map.Entry
	{
		public  Object getKey(){}
		public  Object getValue(){}
	}	
}
*/
~~~

## 练习

每一个学生都有对应的归属地。
学生Student，地址String。
学生属性：姓名，年龄。
注意：姓名和年龄相同的视为同一个学生。
         保证学生的唯一性。

思路：
1，描述学生。
2，定义map容器。将学生作为键，地址作为值，存入。
3，获取map集合中的元素。

~~~Java
import java.util.*;
class Student implements Comparable<Student>
{
	private String name;
	private int age;
	Student(String name,int age)
	{
		this.name = name;
		this.age = age;
	}
	
	public int compareTo(Student s)
	{
		int num = new Integer(this.age).compareTo(new Integer(s.age));

		if(num==0)
			return this.name.compareTo(s.name);
		return num;
	}

	public int hashCode()
	{
		return name.hashCode()+age*34;
	}
	
	public boolean equals(Object obj)
	{
		if(!(obj instanceof Student))
			throw new ClassCastException("类型不匹配");

		Student s = (Student)obj;

		return this.name.equals(s.name) && this.age==s.age;		
	}
	
	public String getName()
	{
		return name;
	}
	
	public int getAge()
	{
		return age;
	}
	
	public String toString()
	{
		return name+":"+age;
	}
}


class  MapTest
{
	public static void main(String[] args) 
	{
		HashMap<Student,String> hm = new HashMap<Student,String>();

		hm.put(new Student("lisi1",21),"beijing");
		hm.put(new Student("lisi1",21),"tianjin");
		hm.put(new Student("lisi2",22),"shanghai");
		hm.put(new Student("lisi3",23),"nanjing");
		hm.put(new Student("lisi4",24),"wuhan");

		//第一种取出方式 keySet

		Set<Student> keySet = hm.keySet();

		Iterator<Student> it = keySet.iterator();

		while(it.hasNext())
		{
			Student stu = it.next();
			String addr = hm.get(stu);
			System.out.println(stu+".."+addr);
		}

		//第二种取出方式 entrySet
		Set<Map.Entry<Student,String>> entrySet = hm.entrySet();

		Iterator<Map.Entry<Student,String>> iter = entrySet.iterator();
		
		while(iter.hasNext())
		{
			Map.Entry<Student,String> me = iter.next();
			Student stu = me.getKey();
			String addr = me.getValue();
			System.out.println(stu+"........."+addr);
		}
	}
}
~~~

需求：对学生对象的年龄进行升序排序。

因为数据是以键值对形式存在的，所以要使用可以排序的Map集合，TreeMap

~~~Java
import java.util.*;

class StuNameComparator implements Comparator<Student>
{
	public int compare(Student s1,Student s2)
	{
		int num = s1.getName().compareTo(s2.getName());
		if(num==0)
			return new Integer(s1.getAge()).compareTo(new Integer(s2.getAge()));

		return num;
	}
}

class  MapTest2
{
	public static void main(String[] args) 
	{
		TreeMap<Student,String> tm = new TreeMap<Student,String>(new StuNameComparator());

		tm.put(new Student("blisi3",23),"nanjing");
		tm.put(new Student("lisi1",21),"beijing");
		tm.put(new Student("alisi4",24),"wuhan");
		tm.put(new Student("lisi1",21),"tianjin");
		tm.put(new Student("lisi2",22),"shanghai");
		
		Set<Map.Entry<Student,String>> entrySet = tm.entrySet();

		Iterator<Map.Entry<Student,String>> it = entrySet.iterator();

		while(it.hasNext())
		{
			Map.Entry<Student,String> me = it.next();

			Student stu = me.getKey();
			String addr = me.getValue();
			System.out.println(stu+":::"+addr);
		}
	}
}
~~~

需求："sdfgzxcvasdfxcvdf"获取该字符串中的字母出现的次数。
希望打印结果：a(1)c(2).....

通过结果发现，每一个字母都有对应的次数，说明字母和次数之间都有映射关系。

注意了，当发现有映射关系时，可以选择map集合。
因为map集合中存放就是映射关系。

什么时候使用map集合呢？
当数据之间存在这映射关系时，就要先想map集合。

思路：
1，将字符串转换成字符数组。因为要对每一个字母进行操作。
2，定义一个map集合，因为打印结果的字母有顺序，所以使用treemap集合。
3，遍历字符数组。
	将每一个字母作为键去查map集合。
	如果返回null，将该字母和1存入到map集合中。
	如果返回不是null，说明该字母在map集合已经存在并有对应次数。
	那么就获取该次数并进行自增，然后将该字母和自增后的次数存入到map集合中，覆盖调用原理键所对应的值。
4，将map集合中的数据变成指定的字符串形式返回。

~~~Java
import java.util.*;
class  MapTest3
{
	public static void main(String[] args) 
	{
		String s= charCount("ak+abAf1c,dCkaAbc-defa");
		System.out.println(s);
	}
	
	public static String charCount(String str)
	{
		char[] chs = str.toCharArray();

		TreeMap<Character,Integer> tm = new TreeMap<Character,Integer>();
		
		int count = 0;
		for(int x=0; x<chs.length; x++)
		{
			if(!(chs[x]>='a' && chs[x]<='z' || chs[x]>='A' && chs[x]<='Z'))
				continue;

			Integer value = tm.get(chs[x]);
			
			if(value!=null)
				count = value;
			count++;
			tm.put(chs[x],count);//直接往集合中存储字符和数字，为什么可以，因为自动装箱。

			count = 0;
			/*
			if(value==null)
			{
				tm.put(chs[x],1);
			}
			else
			{
				value = value + 1;
				tm.put(chs[x],value);
			}
			*/
		}
		//System.out.println(tm);

		StringBuilder sb = new StringBuilder();

		Set<Map.Entry<Character,Integer>> entrySet = tm.entrySet();
		Iterator<Map.Entry<Character,Integer>>  it = entrySet.iterator();

		while(it.hasNext())
		{
			Map.Entry<Character,Integer> me = it.next();
			Character ch = me.getKey();
			Integer value = me.getValue();
			sb.append(ch+"("+value+")");
		}

		return sb.toString();
	}
}
~~~

## 拓展

map扩展知识。

map集合被使用是因为具备映射关系。

"yureban"   Student("01" "zhangsan");
"yureban" Student("02" "lisi");

"jiuyeban" "01" "wangwu";
"jiuyeban" "02" "zhaoliu";

一个学校有多个教室，每一个教室都有名称。

~~~Java
import java.util.*;

class Student
{
	private String id;
	private String name;
	Student(String id,String name)
	{
		this.id = id;
		this.name = name;
	}
	public String toString()
	{
		return id+":::"+name;
	}
}


class  MapDemo3
{
	public static void demo()
	{
		HashMap<String,List<Student>> czbk = new HashMap<String,List<Student>>();

		List<Student> reyu = new ArrayList<Student>();
		List<Student> jiuye = new ArrayList<Student>();

		czbk.put("yureban",reyu);
		czbk.put("jiuyeban",jiuye);

		reyu.add(new Student("01","zhagnsa"));
		reyu.add(new Student("04","wangwu"));
		jiuye.add(new Student("01","zhouqi"));
		jiuye.add(new Student("02","zhaoli"));


		Iterator<String> it = czbk.keySet().iterator();

		while(it.hasNext())
		{
			String roomName = it.next();
			List<Student> room = czbk.get(roomName);
			
			System.out.println(roomName);
			getInfos(room);
		}
	}
    
	public static void getInfos(List<Student> list)
	{
		Iterator<Student> it = list.iterator();
		while(it.hasNext())
		{
			Student s = it.next();
			System.out.println(s);
		}
	}

	public static void main(String[] args) 
	{
		 demo();
		/*
		HashMap<String,List<Student>> czbk = new HashMap<String,List<Student>>();

		HashMap<String,String> yure = new HashMap<String,String>();
		
		HashMap<String,String> jiuye = new HashMap<String,String>();

		czbk.put("yureban",yure);
		czbk.put("jiuyeban",jiuye);

		yure.put("01","zhagnsan");
		yure.put("02","lisi");

		jiuye.put("01","zhaoliu");
		jiuye.put("02","wangwu");


		//遍历czbk集合。获取所有的教室。
		Iterator<String> it = czbk.keySet().iterator();

		while(it.hasNext())
		{
			String roomName = it.next();
			HashMap<String,String> room = czbk.get(roomName);
			
			System.out.println(roomName);
			getStudentInfo(room);
		}		
//		getStudentInfo(jiuye);
//		getStudentInfo(yure);
*/		
	}
    
	public static void getStudentInfo(HashMap<String,String> roomMap)
	{
		Iterator<String> it = roomMap.keySet().iterator();

		while(it.hasNext())
		{
			String id = it.next();
			String name = roomMap.get(id);
			System.out.println(id+":"+name);
		}
	}
}
~~~

# 七、Collections

集合框架的工具类。
Collections:集合框架的工具类，里面定义的都是静态方法。

Collections和Collection有什么区别？
Collection是集合框架中的一个顶层接口，它里面定义了单列集合的共性方法。
它有两个常用的子接口：List：对元素都有定义索引。有序的。可以重复元素。
		    Set：不可以重复元素。无序。

Collections是集合框架中的一个工具类。该类中的方法都是静态的
提供的方法中有可以对list集合进行排序，二分查找等方法。
通常常用的集合都是线程不安全的，因为要提高效率。
如果多线程操作这些集合时，可以通过该工具类中的同步方法，将线程不安全的集合，转换成安全的。

## sort & max & binarySearch

~~~java
import java.util.*;
class  CollectionsDemo
{
	public static void main(String[] args) 
	{
		sortDemo();

	}

	public static void binarySearchDemo()
	{
		List<String> list = new ArrayList<String>();

		list.add("abcd");
		list.add("aaa");
		list.add("zz");
		list.add("kkkkk");
		list.add("qq");
		list.add("z");
		Collections.sort(list,new StrLenComparator());

		sop(list);

		//int index = Collections.binarySearch(list,"aaaa");
		//int index = halfSearch(list,"cc");
		int index = halfSearch2(list,"aaaa",new StrLenComparator());
		sop("index="+index);
	}

	public static int halfSearch(List<String> list,String key)
	{
		int max,min,mid;
		max = list.size()-1;
		min = 0;

		while(min<=max)
		{
			mid = (max+min)>>1;//  /2;

			String str = list.get(mid);

			int num = str.compareTo(key);
			if(num>0)
				max = mid -1;
			else if(num<0)
				min = mid + 1;
			else
				return mid;
		}
		return -min-1;
	}

	public static int halfSearch2(List<String> list,String key,Comparator<String> cmp)
	{
		int max,min,mid;
		max = list.size()-1;
		min = 0;

		while(min<=max)
		{
			mid = (max+min)>>1;//  /2;

			String str = list.get(mid);

			int num = cmp.compare(str,key);
			if(num>0)
				max = mid -1;
			else if(num<0)
				min = mid + 1;
			else
				return mid;
		}
		return -min-1;
	}

	public static void maxDemo()
	{
		List<String> list = new ArrayList<String>();

		list.add("abcd");
		list.add("aaa");
		list.add("zz");
		list.add("kkkkk");
		list.add("qq");
		list.add("z");
		Collections.sort(list);
		sop(list);
		String max = Collections.max(list/*,new StrLenComparator()*/);
		sop("max="+max);
	}

	public static void sortDemo()
	{
		List<String> list = new ArrayList<String>();

		list.add("abcd");
		list.add("aaa");
		list.add("zz");
		list.add("kkkkk");
		list.add("qq");
		list.add("z");
		
		sop(list);

		//Collections.sort(list);
		Collections.sort(list,new StrLenComparator());
		//Collections.swap(list,1,2);
		sop(list);		
	}

	public static void sop(Object obj)
	{
		System.out.println(obj);
	}
}

class StrLenComparator implements Comparator<String>
{
	public int compare(String s1,String s2)
	{
		if(s1.length()>s2.length())
			return 1;
		if(s1.length()<s2.length())
			return -1;
		return s1.compareTo(s2);
	}
}

/*
class Student
{
}
list.add(new Student());

public static <T extends Comparable<? super T>> void sort(List<T> list)
{
	
}
*/
~~~

## reverseOrder & 替换反转

~~~java
import java.util.*;

class StrComparator implements Comparator<String>
{
	public int compare(String s1,String s2)
	{
		/*
		int num = s1.compareTo(s2);
		if(num>0)
			return -1;
		if( num<0)
			return 1;
		return num;
		*/

		return s2.compareTo(s1);
	}
}

class StrLenComparator implements Comparator<String>
{
	public int compare(String s1,String s2)
	{
		if(s1.length()>s2.length())
			return 1;
		if(s1.length()<s2.length())
			return -1;
		return s1.compareTo(s2);
	}
}
class CollectionsDemo2 
{
	public static void main(String[] args) 
	{
		shuffleDemo();
	}
	public static void shuffleDemo()
	{
		List<String> list = new ArrayList<String>();

		list.add("abcd");
		list.add("aaa");
		list.add("zz");
		list.add("kkkkk");
		list.add("qq");
		list.add("z");

		sop(list);
		Collections.shuffle(list);
		sop(list);
	}
	public static void orderDemo()
	{
		TreeSet<String> ts = new TreeSet<String>(Collections.reverseOrder(new StrLenComparator()));

		ts.add("abcde");
		ts.add("aaa");
		ts.add("k");
		ts.add("cc");

		Iterator it = ts.iterator();
		while(it.hasNext())
		{
			System.out.println(it.next());
		}
	}

	public static void replaceAllDemo()
	{
		List<String> list = new ArrayList<String>();

		list.add("abcd");
		list.add("aaa");
		list.add("zz");
		list.add("kkkkk");

		sop(list);

		Collections.replaceAll(list,"aaa","pp");

		sop(list);
		Collections.reverse(list);

		sop(list);
	}


	public static void fillDemo()
	{
		List<String> list = new ArrayList<String>();

		list.add("abcd");
		list.add("aaa");
		list.add("zz");
		list.add("kkkkk");
		
		sop(list);
		Collections.fill(list,"pp");
		sop(list);
	}
	public static void sop(Object obj)
	{
		System.out.println(obj);
	}
}
~~~

# 八、Arrays

Arrays:用于操作数组的工具类，里面都是静态方法。

asList:将数组变成list集合。

~~~java
import java.util.*;
class  ArraysDemo
{
	public static void main(String[] args) 
	{
//		int[] arr = {2,4,5};
//
//		System.out.println(Arrays.toString(arr));

		String[] arr = {"abc","cc","kkkk"};


		//把数组变成list集合有什么好处？
		/*
		可以使用集合的思想和方法来操作数组中的元素。

		注意：将数组变成集合，不可以使用集合的增删方法。
		因为数组的长度是固定。
		contains。
		get
		indexOf()
		subList();

		如果你增删。那么会反生UnsupportedOperationException,

		*/
		List<String> list = Arrays.asList(arr);
		//sop("contains:"+list.contains("cc"));
		//list.add("qq");//UnsupportedOperationException,

		//sop(list);

		//int[] nums = {2,4,5};
		Integer[] nums = {2,4,5};

		
		List<Integer> li = Arrays.asList(nums);

		/*
		如果数组中的元素都是对象。那么变成集合时，数组中的元素就直接转成集合中的元素。
		如果数组中的元素都是基本数据类型，那么会将该数组作为集合中的元素存在。
		*/
		sop(li);
	}
	public static boolean myContains(String[] arr,String key)
	{
		for(int x=0;x<arr.length; x++)
		{
			if(arr[x].equals(key))
				return true;
		}
		return false;
	}
	
	public static void sop(Object obj)
	{
		System.out.println(obj);
	}

}
~~~

集合变数组。
Collection接口中的toArray方法。

~~~java
import java.util.*;
class  CollectionToArray
{
	public static void main(String[] args) 
	{
		ArrayList<String> al = new ArrayList<String>();

		al.add("abc1");
		al.add("abc2");
		al.add("abc3");
		
		/*
		1,指定类型的数组到底要定义多长呢？
		当指定类型的数组长度小于了集合的size，那么该方法内部会创建一个新的数组。长度为集合的size。
		当指定类型的数组长度大于了集合的size，就不会新创建了数组。而是使用传递进来的数组。
		所以创建一个刚刚好的数组最优。
		
		2,为什么要将集合变数组？
		为了限定对元素的操作。不需要进行增删了。

		*/
		String[] arr = al.toArray(new String[al.size()]);

		System.out.println(Arrays.toString(arr));
	}
}
~~~

# 九、拓展

## 增强for循环

格式：
for(数据类型 变量名 : 被遍历的集合(Collection)或者数组)
{	
}

对集合进行遍历，只能获取集合元素，但是不能对集合进行操作。

迭代器除了遍历，还可以进行remove集合中元素的动作。
如果是用ListIterator，还可以在遍历过程中对集合进行增删改查的动作。

传统for和高级for有什么区别呢？
高级for有一个局限性，必须有被遍历的目标。

建议在遍历数组的时候，还是希望用传统for，因为传统for可以定义脚标。

~~~Java
import java.util.*;

class ForEachDemo 
{
	public static void main(String[] args) 
	{	
		ArrayList<String> al = new ArrayList<String>();

		al.add("abc1");
		al.add("abc2");
		al.add("abc3");

		for(String s : al)
		{
			//s = "kk";
			System.out.println(s);
		}

		System.out.println(al);
		/*
		Iterator<String> it = al.iterator();

		while(it.hasNext())
		{
			System.out.println(it.next());
		}
		*/

		int[] arr = {3,5,1};

		for(int x=0; x<arr.length; x++)
		{
			System.out.println(arr[x]);
		}
		for(int i : arr)
		{
			System.out.println("i:"+i);
		}

		HashMap<Integer,String> hm = new HashMap<Integer,String>();

		hm.put(1,"a");
		hm.put(2,"b");
		hm.put(3,"c");

		Set<Integer> keySet = hm.keySet();
		for(Integer i : keySet)
		{
			System.out.println(i+"::"+hm.get(i));
		}

//		Set<Map.Entry<Integer,String>> entrySet = hm.entrySet();
//		for(Map.Entry<Integer,String> me : entrySet)

		for(Map.Entry<Integer,String> me : hm.entrySet())
		{
			System.out.println(me.getKey()+"------"+me.getValue());
		}

	}
}
~~~

## 可变参数

JDK1.5版本出现的新特性。

方法的可变参数。
在使用时注意：可变参数一定要定义在参数列表最后面。

~~~Java
class  ParamMethodDemo
{
	public static void main(String[] args) 
	{
		//show(3,4);
		/*
		//虽然少定义了多个方法。
		但是每次都要定义一个数组，作为实际参数。

		int[] arr = {3,4};
		show(arr);

		int[] arr1 = {2,3,4,5};
		show(arr1);
		*/

		/*
		可变参数。
		其实就是上一种数组参数的简写形式。
		不用每一次都手动的建立数组对象。
		只要将要操作的元素作为参数传递即可。
		隐式将这些参数封装成了数组。
		*/
		show("haha",2,3,4,5,6);
		//show(2,3,4,5,6,4,2,35,9,"heh");
		//show();

	}
	public static void show(String str,int... arr)
	{
		System.out.println(arr.length);
	}
	/*
	public static void show(int[] arr)
	{
		
	}
	*/
	/*
	public static  void show(int a,int b)
	{
		System.out.println(a+","+b);
	}
	public static  void show(int a,int b,int c)
	{}
	*/
}
~~~

## 静态导入

StaticImport  静态导入。

当类名重名时，需要指定具体的包名。
当方法重名时，指定具备所属的对象或者类。

~~~java
import java.util.*;
import static  java.util.Arrays.*;//导入的是Arrays这个类中的所有静态成员。
import static java.util.Collections.*;
/*
packa/Demo.class 
packb/Demo.class

import packa.*;
import packb.*;
*/

import static  java.lang.System.*;//导入了System类中所有静态成员。

class  StaticImport //extends Object
{
	public static void main(String[] args) 
	{
		out.println("haha");
		int[] arr = {3,1,5};

		sort(arr);
		int index = binarySearch(arr,1);
		out.println(Arrays.toString(arr));
		System.out.println("Index="+index);

		ArrayList al = new ArrayList();
		al.add(1);
		al.add(3);
		al.add(2);

		out.println(al);

		sort(al);
		out.println(al);
	}
}
~~~

# 十、其他对象

## System

System:类中的方法和属性都是静态的。
out:标准输出，默认是控制台。
in：标准输入，默认是键盘。

描述系统一些信息。
获取系统属性信息：Properties getProperties();

~~~java
import java.util.*;
class SystemDemo 
{
	public static void main(String[] args) 
	{
		Properties prop = System.getProperties();
		
		//因为Properties是Hashtable的子类，也就是Map集合的一个子类对象。
		//那么可以通过map的方法取出该集合中的元素。
		//该集合中存储都是字符串。没有泛型定义。
		
		//如何在系统中自定义一些特有信息呢？
		System.setProperty("mykey","myvalue");

		//获取指定属性信息。
		String value = System.getProperty("os.name");

		System.out.println("value="+value);

		//可不可以在jvm启动时，动态加载一些属性信息呢？
		String v = System.getProperty("haha");

		System.out.println("v="+v);

		/*
		//获取所有属性信息。
		for(Object obj : prop.keySet())
		{
			String value = (String)prop.get(obj);

			System.out.println(obj+"::"+value);
		}
		*/
	}
}
~~~

## Runtime

Runtime对象，该类并没有提供构造函数，说明不可以new对象。
那么会直接想到该类中的方法都是静态的，发现该类中还有非静态方法，
说明该类肯定会提供了方法获取本类对象，而且该方法是静态的，并返回值类型是本类类型。
由这个特点可以看出该类使用了单例设计模式完成。

该方式是static Runtime getRuntime();

~~~java
class  RuntimeDemo
{
	public static void main(String[] args) throws Exception
	{
		Runtime r = Runtime.getRuntime();
		Process p = r.exec("notepad.exe  SystemDemo.java");
		
		//Thread.sleep(4000);
		//p.destroy();

	}
}

~~~

## Date

~~~java
import java.util.*;
import java.text.*;
class DateDemo 
{
	public static void main(String[] args) 
	{
		Date d = new Date();
		System.out.println(d);//打印的时间看不懂，希望有些格式。

		//将模式封装到SimpleDateformat对象中。
		SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日E hh:mm:ss");
		
		//调用format方法让模式格式化指定Date对象。

		String time = sdf.format(d);

		System.out.println("time="+time);

		long l = System.currentTimeMillis();

		Date d1 = new Date(l);

		System.out.println("d1:"+d1);
	}
}
~~~

## Calendar

~~~java
import java.util.*;
import java.text.*;

class  CalendarDemo
{
	public static void main(String[] args) 
	{

		Calendar c = Calendar.getInstance();


		String[] mons = {"一月","二月","三月","四月"
					,"五月","六月","七月","八月"
					,"九月","十月","十一月","十二月"};

		String[] weeks = {
						"","星期日","星期一","星期二","星期三","星期四","星期五","星期六",
							};		
		int index = c.get(Calendar.MONTH);

		int index1 = c.get(Calendar.DAY_OF_WEEK);

		sop(c.get(Calendar.YEAR)+"年");
		//sop((c.get(Calendar.MONTH)+1)+"月");
		sop(mons[index]);
		sop(c.get(Calendar.DAY_OF_MONTH)+"日");
		//sop("星期"+c.get(Calendar.DAY_OF_WEEK));
		sop(weeks[index1]);
		/*
		Date d = new Date();

		SimpleDateFormat sdf = new SimpleDateFormat("yyyy");

		String year = sdf.format(d);

		System.out.println(year);

		*/
	}

	public static void sop(Object obj)
	{
		System.out.println(obj);
	}
}
~~~

## Math

练习：给定一个小数，保留该小数的后两位。

~~~java
import java.util.*;

class  MathDemo
{
	public static void main(String[] args) 
	{		
		/*
		Random r = new Random();
		for(int x=0; x<10; x++)
		{
			//int d = (int)(Math.random()*10+1);
			int d = r.nextInt(10)+1;
			sop(d);
		}
		*/
		saveTwo(12.3456,3,true);//12.34
	}

	public static void saveTwo(double d,int scale,boolean isRound)
	{
		
		double base = Math.pow(10,scale);

		double num = isRound?Math.round(d*base)/base:((int)(d*base))/base;

		sop("num="+num);

		/*
		double d1 = d*100;
		sop("d1="+d1);
		d1 = d1+0.5;
		double d2 = (int)d1;
		sop("d2="+d2);
		double d3 = d2/100;
		sop("d3="+d3);
		*/
	}

	public static void show()
	{
		double d = Math.ceil(16.34);//ceil返回大于指定数据的最小整数。
		double d1 = Math.floor(12.34);//floor返回小于指定数据的最大整数。

		long l = Math.round(12.54);//四舍五入
		sop("d="+d);
		sop("d1="+d1);
		sop("l="+l);

		double d2 = Math.pow(2,3);
		sop("d2="+d2);
	}
	public static void sop(Object obj)
	{
		
		System.out.println(obj);
	}
}
~~~

